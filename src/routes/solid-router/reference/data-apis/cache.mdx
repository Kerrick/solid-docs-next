---
title: cache
---

## `cache`

`cache` is a [higher-order function](https://en.wikipedia.org/wiki/Higher-order_function) that creates a function with the same signature as the function passed to it.
When created function is called with a given set of arguments for the first time, the original function is run and its return value is both stored in a cache and returned to the caller of the created function.
When the created function is called with the same arguments before the cache becomes stale, the original function is not re-run â€” instead, it will receive the previous return value stored in the cache.

As an example, wrapping network calls with `cache` can help prevent duplicate fetches of identical data from occurring in quick succession.

`cache` accomplishes the following:

1. Deduping on the server for the lifetime of the request.
2. Preloading the cache in the browser - this lasts 10 seconds.
   When a route is preloaded on hover or when load is called when entering a route it will make sure to dedupe calls.
3. A reactive refetch mechanism based on key.
   This prevents routes that are not new from retriggering on action revalidation.
4. Serve as a back/forward cache for browser navigation for up to 5 minutes.
   Any user based navigation or link click bypasses it.
   Upon revalidation or new fetch the cache is updated.

### Arguments

| argument | type | description |
| -------- | ---- | ----------- |
| fn | `(...args: any) => any` | A function whose return value you'd like to be cached. This function can have any arguments you'd like, and the arguments will be deterministically serialized and used as part of the unique key for the cache. This serialization process uses `JSON.stringify`, but first sorts the key/value pairs of objects to ensure `{ name: 'Ryan', awesome: true }` serializes to the same value as `{ awesome: true, name: 'Ryan' }`. |
| name | string | Any arbitrary string that you'd like to use as the rest of the cache key. Because the cache used internally by `cache` is shared by all cached functions, this string should be unique for each unique function passed to `cache`. If you instead use the same key for two different cached functions, it's possible that one will give you back the return value from the other. |

### Return Value

The return value is a `CachedFunction`, a function that has the same signature as the function you passed to `cache`.
This cached function stores the return value using the cache key. 
Under most circumstances, this temporarily prevents the passed function from running with the same arguments, even if the created function is called repeatedly.
### `.key` and `.keyFor`

Cached functions provide `.key` and `.keyFor`, which are useful when retrieving the keys used in cases involving invalidation:

```ts
let id = 5;
getUser.key; // returns "users"
getUser.keyFor(id); // returns "users[5]"

### Examples


```js
const getUser = cache(
  (id, options = {}) => fetch(`/api/users/${id}?summary=${options.summary || false}`).then(r => r.json()),
  "usersById"
);

getUser(123); // Causes a GET request to /api/users/123?summary=false
getUser(123); // Does not cause a GET request
getUser(123, { summary: true }); // Causes a GET request to /api/users/123?summary=true
setTimeout(() => getUser(123, { summary: true }), 999000); // Eventually causes another GET request to /api/users/123?summary=true
```

Using it with a [load function](https://docs.solidjs.com/solid-router/reference/load-functions/load):

```js
import { lazy } from "solid-js";
import { Route } from "@solidjs/router";
import { getUser } from ... // the cache function

const User = lazy(() => import("./pages/users/[id].js"));

// load function
function loadUser({params, location}) {
  void getUser(params.id)
}

// Pass it in the route definition
<Route path="/users/:id" component={User} load={loadUser} />;
```

Using it inside a Route's component:

```jsx
// pages/users/[id].js
import { getUser } from ... // the cache function

export default function User(props) {
  const user = createAsync(() => getUser(props.params.id));
  return <h1>{user().name}</h1>;
}
```

<Callout>
  `cache` can be defined anywhere and then used inside your components with [`createAsync`](/solid-router/reference/data-apis/create-async).

However, using `cache` directly in [`createResource`](/reference/basic-reactivity/create-resource) will not work since the fetcher is not reactive and will not invalidate properly.

</Callout>


```ts
let id = 5;

getUser.key; // returns "users"
getUser.keyFor(id); // returns "users[5]"
```

## `revalidate`

The cache can be revalidated using the `revalidate` method or the `revalidate` keys that are set on the response from the actions.
If the whole key is passed, it will invalidate all entries for the cache (ie. `users` in the example above).
If only a single entry needs to be invalidated, `keyFor` is provided.
To revalidate everything in the cache, pass `undefined` as the key.
