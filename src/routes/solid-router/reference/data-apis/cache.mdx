---
title: cache
---

## `cache`

`cache` is a [higher-order function](https://en.wikipedia.org/wiki/Higher-order_function) that creates a function with the same signature as the function you passed to it. When you call the created function with a given set of arguments for the first time, your original function is run and its return value is both stored in a cache and returned to the caller of the created function. When you call the created function with the same arguments again before the cache becomes stale, your original function is not re-runâ€”you instead immediately receive the previous return value stored in the cache. A common use case is to wrap network calls so that duplicate fetches for the same data in quick succession can be avoided.

This cache accomplishes the following:

1. Deduping on the server for the lifetime of the request.
2. Preloading the cache in the browser - this lasts 10 seconds.
   When a route is preloaded on hover or when load is called when entering a route it will make sure to dedupe calls.
3. A reactive refetch mechanism based on key.
   This prevents routes that are not new from retriggering on action revalidation.
4. Serve as a back/forward cache for browser navigation for up to 5 minutes.
   Any user based navigation or link click bypasses it.
   Upon revalidation or new fetch the cache is updated.

### Arguments

| argument | type | description |
| -------- | ---- | ----------- |
| fn | `(...args: any) => any` | A function whose return value you'd like to be cached. This function can have any arguments you'd like, and the arguments will be deterministically serialized and used as part of the unique key for the cache. This serialization process uses `JSON.stringify`, but first sorts the key/value pairs of objects to ensure `{ name: 'Ryan', awesome: true }` serializes to the same value as `{ awesome: true, name: 'Ryan' }`. |
| name | string | Any arbitrary string that you'd like to use as the rest of the cache key. Because the cache used internally by `cache` is shared by all cached functions, this string should be unique for each unique function passed to `cache`. If you instead use the same key for two different cached functions, it's possible that one will give you back the return value from the other. |

### Return Value

The return value is a `CachedFunction`, a function that has the same signature as the function you passed to `cache`. This cached function stores the return value (using the cache key as described above) and temporarily avoids re-running the passed function again for the same set of arguments under most circumstances, even if you call the created function multiple times. The returned function also has `key` and `keyFor` properties, described below.

### Examples


```js
const getUser = cache(
  (id, options = {}) => fetch(`/api/users/${id}?summary=${options.summary || false}`).then(r => r.json()),
  "usersById"
);

getUser(123); // Causes a GET request to /api/users/123?summary=false
getUser(123); // Does not cause a GET request
getUser(123, { summary: true }); // Causes a GET request to /api/users/123?summary=true
setTimeout(() => getUser(123, { summary: true }), 999000); // Eventually causes another GET request to /api/users/123?summary=true
```

Using it with a [load function](https://docs.solidjs.com/solid-router/reference/load-functions/load):

```js
import { lazy } from "solid-js";
import { Route } from "@solidjs/router";
import { getUser } from ... // the cache function

const User = lazy(() => import("./pages/users/[id].js"));

// load function
function loadUser({params, location}) {
  void getUser(params.id)
}

// Pass it in the route definition
<Route path="/users/:id" component={User} load={loadUser} />;
```

Using it inside a Route's component:

```jsx
// pages/users/[id].js
import { getUser } from ... // the cache function

export default function User(props) {
  const user = createAsync(() => getUser(props.params.id));
  return <h1>{user().name}</h1>;
}
```

<Callout>
  `cache` can be defined anywhere and then used inside your components with [`createAsync`](/solid-router/reference/data-apis/create-async).

However, using `cache` directly in [`createResource`](/reference/basic-reactivity/create-resource) will not work since the fetcher is not reactive and will not invalidate properly.

</Callout>

### `CachedFunction.keyFor` and `CachedFunction.key`

Cached functions provide a property and method useful for getting the key that can be used in cases with invalidation:

```ts
let id = 5;

getUser.key; // returns "users"
getUser.keyFor(id); // returns "users[5]"
```

## `revalidate`

The cache can be revalidated using the `revalidate` method or the `revalidate` keys that are set on the response from the actions.
If the whole key is passed, it will invalidate all entries for the cache (ie. `users` in the example above).
If only a single entry needs to be invalidated, `keyFor` is provided.
To revalidate everything in the cache, pass `undefined` as the key.
